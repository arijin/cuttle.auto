/*
 * Copyright (C) 2019 by AutoSense Organization. All rights reserved.
 * Gary Chan <chenshj35@mail2.sysu.edu.cn>
 */
#ifndef ROI_FILTERS_INCLUDE_ROI_FILTERS_ROI_HPP_
#define ROI_FILTERS_INCLUDE_ROI_FILTERS_ROI_HPP_

#include <pcl/filters/approximate_voxel_grid.h>  // pcl::ApproximateVoxelGrid
#include <pcl/filters/passthrough.h>             // pcl::PassThrough
#include <pcl/filters/radius_outlier_removal.h>  // pcl::RadiusOutlierRemoval
#include <pcl/filters/voxel_grid.h>              // pcl::VoxelGrid

#include <algorithm>
#include <cmath>
#include <vector>

#include "common/common.hpp"    // common::EPSILON
#include "common/geometry.hpp"  // common::geometry::calcCylinderDistNorm
#include "common/types/type.h"  // VolumetricModel_Human/VolumetricModel_Car
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/opencv.hpp"

namespace autosense {
namespace roi {

template <typename PointT>
static void elevationBandPass(float z_limit_min,
                              float z_limit_max,
                              typename pcl::PointCloud<PointT>::Ptr cloud) {
    if (cloud->size()) {
        typename pcl::PointCloud<PointT>::Ptr cloud_in(
            new pcl::PointCloud<PointT>);
        *cloud_in = *cloud;
        cloud->clear();

        pcl::PassThrough<Point> passFilter;
        passFilter.setFilterFieldName("z");
        passFilter.setFilterLimits(z_limit_min, z_limit_max);
        passFilter.setInputCloud(cloud_in);
        passFilter.filter(*cloud);
    }
}

/*
 * @brief Tail Water Noises Outlier Removal
 * @note
    TailOutlierRemoval is a simple filter that removes
    outliers which is generated by the ship and if often
    distribute on the tail of the ship.
 * @note
 *  angle threshold: 5,
 *  longitudinal range: -8.0
 */
template <typename PointT>
bool isinfinite(PointT point) {
    if (!pcl_isfinite(point.x) || !pcl_isfinite(point.y) ||
        !pcl_isfinite(point.z)) {
        return true;
    }
    return false;
}

template <typename PointT>
double getEdgeAngle(PointT pointA, PointT pointB) {
    const double d_1 = common::geometry::calcCylinderDistNorm<PointT>(pointA);
    const double d_2 = common::geometry::calcCylinderDistNorm<PointT>(pointB);
    double included_angle =
        abs(atan2(pointA.y, pointA.x) - atan2(pointB.y, pointB.x));
    if (included_angle > 3.1415926)
        included_angle = 3.1415926 * 2 - included_angle;
    double edge_angle =
        atan(sin(included_angle) * d_2 / (d_1 - d_2 * cos(included_angle)));
    double other_edge_angle = 3.1415926 - included_angle - edge_angle;
    edge_angle = std::min(edge_angle, other_edge_angle);
    return edge_angle / 3.1415926 * 180;
}

template <typename PointT>
double getEdgeDistance(PointT pointA, PointT pointB) {
    return sqrt(pow(pointA.x - pointB.x, 2.0) + pow(pointA.y - pointB.y, 2.0));
}

template <typename PointT>
static void TailOutlierRemovalFilter(
    typename pcl::PointCloud<PointT>::Ptr cloud,
    float lateral_range = 5.,
    float longitudinal_range = -8.,
    float dis_tolerance = 0.5) {
    if (cloud->size()) {
        for (size_t h = 0; h < cloud->height; ++h) {
            for (size_t w = 0; w < cloud->width; ++w) {
                // int pt = h * cloud->width + w;
                // const PointT& point = cloud->points[pt];
                const PointT& point = cloud->at(w, h);
                if (isinfinite<PointT>(point)) continue;
                if (point.x > longitudinal_range && point.x < 0 &&
                    point.y > -lateral_range && point.y < lateral_range) {
                    int left = (w - 1 >= 0) ? w - 1 : cloud->width - 1;
                    int right = (w + 1 <= cloud->width - 1) ? w + 1 : 0;
                    int top = h + 1;
                    int bottom = h - 1;
                    int near_num = 0;
                    if (!isinfinite<PointT>(cloud->at(left, h)) &&
                        getEdgeDistance(point, cloud->at(left, h)) <
                            dis_tolerance)
                        near_num++;
                    if (!isinfinite<PointT>(cloud->at(right, h)) &&
                        getEdgeDistance(point, cloud->at(right, h)) <
                            dis_tolerance)
                        near_num++;
                    if (top < 16 && !isinfinite<PointT>(cloud->at(w, top)) &&
                        getEdgeDistance(point, cloud->at(w, top)) <
                            dis_tolerance)
                        near_num++;
                    if (bottom >= 0 &&
                        !isinfinite<PointT>(cloud->at(w, bottom)) &&
                        getEdgeDistance(point, cloud->at(w, bottom)) <
                            dis_tolerance)
                        near_num++;
                    if (near_num < 2) {
                        cloud->at(w, h).x = NAN;
                        cloud->at(w, h).y = NAN;
                        cloud->at(w, h).z = NAN;
                    }
                }
            }
        }
    }
}

/*
 * @brief Radius Outlier Removal
 * @note
    RadiusOutlierRemoval is a simple filter that removes
    outliers if the number of neighbors in a certain search
     radius is smaller than a given K.
 * @note
 *  search_radius: 1.0
 *  min_point_number_in_radius: 5
 */
template <typename PointT>
static void RadiusOutlierRemovalFilter(
    float search_radius,
    int min_point_number_in_radius,
    typename pcl::PointCloud<PointT>::Ptr cloud) {
    if (cloud->size()) {
        typename pcl::PointCloud<PointT>::Ptr cloud_in(
            new pcl::PointCloud<PointT>);
        *cloud_in = *cloud;
        cloud->clear();

        pcl::RadiusOutlierRemoval<PointT> outrem;
        // build the filter
        outrem.setRadiusSearch(search_radius);
        outrem.setMinNeighborsInRadius(min_point_number_in_radius);
        outrem.setKeepOrganized(true);
        // apply filter
        outrem.setInputCloud(cloud_in);
        outrem.filter(*cloud);
    }
}

/*
 * @brief Voxel Grid Downsampling
 * @note
 *  SegMatch: A voxel grid is then applied to the resulting source
 * cloud, in order to filter-out noise in voxels where there is not
 * enough evidence for occupancy.
 * @note Configuration follows SegMatch
 * @note
 *  voxel_size: 0.1f
 *  min_point_number_per_voxel: 1
 */
template <typename PointT>
static void voxelGridFilter(float voxel_size,
                            int min_point_number_per_voxel,
                            typename pcl::PointCloud<PointT>::Ptr cloud) {
    if (cloud->size()) {
        typename pcl::PointCloud<PointT>::Ptr cloud_in(
            new pcl::PointCloud<PointT>);
        *cloud_in = *cloud;
        cloud->clear();

        pcl::VoxelGrid<PointT> voxelFilter;
        voxelFilter.setLeafSize(voxel_size, voxel_size, voxel_size);
        voxelFilter.setMinimumPointsNumberPerVoxel(min_point_number_per_voxel);
        voxelFilter.setInputCloud(cloud_in);
        voxelFilter.filter(*cloud);
    }
}

template <typename PointT>
static void approxVoxelGridFilter(float voxel_size,
                                  int min_point_number_per_voxel,
                                  typename pcl::PointCloud<PointT>::Ptr cloud) {
    if (cloud->size()) {
        typename pcl::PointCloud<PointT>::Ptr cloud_in(
            new pcl::PointCloud<PointT>);
        *cloud_in = *cloud;
        cloud->clear();

        pcl::ApproximateVoxelGrid<PointT> voxelFilter;
        voxelFilter.setLeafSize(voxel_size, voxel_size, voxel_size);
        voxelFilter.setMinimumPointsNumberPerVoxel(min_point_number_per_voxel);
        voxelFilter.setInputCloud(cloud_in);
        voxelFilter.filter(*cloud);
    }
}

/*
 * @brief Cylinder(middle center[x,y,z], radius_m, height_above_m,
 * height_below_m) Filter
 * @result cloud after filter
 */
template <typename PointT>
static void cylinderROIFilter(float radius_min,
                              float radius_max,
                              float z_limit_min,
                              float z_limit_max,
                              typename pcl::PointCloud<PointT>::Ptr cloud,
                              bool KeepOrganized = true) {
    if (!KeepOrganized) {
        if (cloud->size()) {
            typename pcl::PointCloud<PointT>::Ptr cloud_in(
                new pcl::PointCloud<PointT>);
            *cloud_in = *cloud;
            cloud->clear();

            const double radius_min_squared = pow(radius_min, 2.0);
            const double radius_max_squared = pow(radius_max, 2.0);

            for (size_t pt = 0u; pt < cloud_in->size(); ++pt) {
                const PointT& point = cloud_in->points[pt];
                const double dist =
                    common::geometry::calcCylinderDistNorm<PointT>(point);
                // Step 1: filter out a large part
                if (dist > radius_min_squared && dist < radius_max_squared) {
                    if (point.z > z_limit_min && point.z < z_limit_max) {
                        cloud->points.push_back(point);
                    }
                }
            }
        }
    } else {
        if (cloud->size()) {
            const double radius_min_squared = pow(radius_min, 2.0);
            const double radius_max_squared = pow(radius_max, 2.0);

            for (size_t pt = 0u; pt < cloud->size(); ++pt) {
                PointT& point = cloud->points[pt];
                const double dist =
                    common::geometry::calcCylinderDistNorm<PointT>(point);
                // Step 1: filter out a large part
                if (dist <= radius_min_squared || dist > radius_max_squared ||
                    point.z <= z_limit_min || point.z >= z_limit_max) {
                    point.x = NAN;
                    point.y = NAN;
                    point.z = NAN;
                }
            }
        }
    }
}

/**
 * @brief forward radius_max(/m), left/right radius_min separately
 * @note Velodyne Coordinate
 *          |x(forward)
 *      C   |   D
 *          |
 *  y---------------
 *          |
 *      B   |   A
 */
template <typename PointT>
static void squareROIFilter(float radius_min,
                            float radius_max,
                            float z_limit_min,
                            float z_limit_max,
                            typename pcl::PointCloud<PointT>::Ptr cloud,
                            bool KeepOrganized = true) {
    if (!KeepOrganized) {
        if (cloud->size()) {
            typename pcl::PointCloud<PointT>::Ptr cloud_in(
                new pcl::PointCloud<PointT>);
            *cloud_in = *cloud;
            cloud->clear();

            const float forward = radius_max;
            const float back = -radius_max;
            const float left = -radius_min;
            const float right = radius_min;

            for (size_t pt = 0u; pt < cloud_in->size(); ++pt) {
                const PointT& point = cloud_in->points[pt];
                // Step 1: filter out a large part
                if (point.y > left && point.y < right) {
                    // Step 2: filter out small part
                    if (point.z > z_limit_min && point.z < z_limit_max) {
                        // Step 3: almost not filter out
                        if (point.x > back && point.x < forward) {
                            cloud->points.push_back(point);
                        }
                    }
                }
            }
        }
    } else {
        if (cloud->size()) {
            const float forward = radius_max;
            const float back = -radius_max;
            const float left = -radius_min;
            const float right = radius_min;

            for (size_t pt = 0u; pt < cloud->size(); ++pt) {
                PointT& point = cloud->points[pt];
                if (point.y <= left || point.y >= right ||
                    point.z <= z_limit_min || point.z >= z_limit_max ||
                    point.x <= back || point.x >= forward) {
                    point.x = NAN;
                    point.y = NAN;
                    point.z = NAN;
                }
            }
        }
    }
}

/**
 * @brief Bird Eye View
 *          |x(forward)
 *      C---|---D
 *      |   |   |
 *      |   |   |
 *  y---------------
 *      B---|---A
 *
 */
template <typename PointT>
static void bevROIFilter(float x_forward,
                         float x_back,
                         float half_width,
                         typename pcl::PointCloud<PointT>::Ptr cloud) {
    if (cloud->size()) {
        typename pcl::PointCloud<PointT>::Ptr cloud_in(
            new pcl::PointCloud<PointT>);
        *cloud_in = *cloud;
        cloud->clear();

        const float forward = x_forward;
        const float back = -x_back;
        const float left = half_width;
        const float right = -half_width;

        for (size_t pt = 0u; pt < cloud_in->size(); ++pt) {
            const PointT& point = cloud_in->points[pt];

            if (point.x > back && point.x < forward) {
                if (point.y < left && point.y > right) {
                    continue;
                }
            }

            cloud->points.push_back(point);
        }
    }
}

// ### Interface ###

/**
 * @note Pointcloud Noise Filter interface
 */
template <typename PointT>
static void applyNoiseFilter(const NoiseParams& params,
                             typename pcl::PointCloud<PointT>::Ptr cloud) {
    // const float search_radius = params.search_radius_m;
    // const int min_point_number_in_radius =
    // params.min_point_number_in_radius_m;
    // RadiusOutlierRemovalFilter<PointT>(search_radius,
    //                                    min_point_number_in_radius,
    //                                    cloud);
    if (cloud->isOrganized())
        TailOutlierRemovalFilter<PointT>(cloud);
    else
        ROS_INFO_STREAM(
            "Cloud is not organized, no Noise Filter is processed!");
}

/**
 * @note Pointcloud ROI Filter interface
 */
template <typename PointT>
static void applyROIFilter(const ROIParams& params,
                           typename pcl::PointCloud<PointT>::Ptr cloud,
                           bool KeepOrganized = true) {
    const float roi_radius_min = params.roi_radius_min_m;
    const float roi_radius_max = params.roi_radius_max_m;
    const float roi_z_limit_min =
        (-1.0) * (params.roi_lidar_height_m + params.roi_height_below_m);
    const float roi_z_limit_max =
        params.roi_height_above_m - params.roi_lidar_height_m;

    if (params.type == "Cylinder") {
        cylinderROIFilter<PointI>(roi_radius_min, roi_radius_max,
                                  roi_z_limit_min, roi_z_limit_max, cloud,
                                  KeepOrganized);
    } else if (params.type == "Square") {
        squareROIFilter<PointI>(roi_radius_min, roi_radius_max, roi_z_limit_min,
                                roi_z_limit_max, cloud, KeepOrganized);
    } else {
        cylinderROIFilter<PointI>(roi_radius_min, roi_radius_max,
                                  roi_z_limit_min, roi_z_limit_max, cloud,
                                  KeepOrganized);
    }
}

//
// ======================= object filter ===========================
//

/**
 * @brief water obstacle-like volumetric model is used to filter out
 * over- and under-segmented clusters
 */
static void waterObstacleModelFilter(const std::vector<ObjectPtr>& objects_in,
                                     const VolumetricModel& model,
                                     std::vector<ObjectPtr>* objects_filtered) {
    std::vector<ObjectPtr> objects(objects_in.begin(), objects_in.end());
    (*objects_filtered).clear();
    for (size_t obj_id = 0u; obj_id < objects.size(); ++obj_id) {
        double length = objects[obj_id]->length;
        double width = objects[obj_id]->width;
        double height = objects[obj_id]->height;

        if (abs(model.l_min - model.l_max) > common::EPSILON &&
            (length < model.l_min || length > model.l_max)) {
            continue;
        }

        if (abs(model.w_min - model.w_max) > common::EPSILON &&
            (width < model.w_min || width > model.w_max)) {
            continue;
        }

        // neglect the obstacles over the boat height.
        if (objects[obj_id]->ground_center[2] > model.h_max) {
            continue;
        }
        // neglect the small obstacles on the water which does not
        // influence passing. Or , this is just the noises.
        if (objects[obj_id]->ground_center[2] + height < model.h_min &&
            height < 0.2)
            continue;

        objects[obj_id]->type = WATER_OBSTACLE;
        (*objects_filtered).push_back(objects[obj_id]);
    }
}

// interface
static std::vector<ObjectPtr> applyVolumetricModelFilter(
    const VolumetricModelParams& volumetric_model_param,
    const std::vector<ObjectPtr> objects) {
    if (volumetric_model_param.use_water_obstacle_model) {
        std::vector<ObjectPtr> objects_filtered;
        waterObstacleModelFilter(objects,
                                 volumetric_model_param.model_water_obstacle,
                                 &objects_filtered);
        return objects_filtered;
    }
    return objects;
}

static void MapROIFilter(const std::vector<ObjectPtr>& objects_in,
                         const std::vector<MapROIParams> roi,
                         const Eigen::Matrix4d& trans_pose,
                         std::vector<ObjectPtr>* objects_filtered) {
    std::vector<cv::Point2f> polygon_vertexes;
    for (int pt_i = 0; pt_i < roi.size(); pt_i++) {
        cv::Point2f pt;
        pt.x = roi[pt_i].x;
        pt.y = roi[pt_i].y;
        polygon_vertexes.push_back(pt);
    }
    std::vector<ObjectPtr> objects(objects_in.begin(), objects_in.end());
    (*objects_filtered).clear();
    for (size_t obj_id = 0u; obj_id < objects.size(); ++obj_id) {
        //   Transform center 地表中心转换到世界坐标系
        Eigen::Vector3d center = objects[obj_id]->ground_center;
        center =
            (trans_pose * Eigen::Vector4d(center[0], center[1], center[2], 1))
                .head(3);
        cv::Point2f p_query(center[0], center[1]);
        if (cv::pointPolygonTest(polygon_vertexes, p_query, true) < 0) {
            continue;
        }
        (*objects_filtered).push_back(objects[obj_id]);
    }
}

}  // namespace roi
}  // namespace autosense

#endif  // ROI_FILTERS_INCLUDE_ROI_FILTERS_ROI_HPP_
